# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code for a registry of multiple snippets."""


import collections
import os
from typing import Generator, Iterable, Optional, Tuple

import jinja2

from snipphthalate import comment
from snipphthalate import context
from snipphthalate import plugin
from snipphthalate import snippet


class NotFoundError(snippet.RenderError):
  """A snippet was not found."""


def _self_and_parent_tags(tag: str) -> Generator[str, None, None]:
  """Yields the given tag and all parent tag scopes.

  E.g., the tag 'foo/bar(quux)' would yield itself, 'foo/bar', 'foo', and ''.

  Args:
    tag: Tag to yield from.
  """
  yield tag
  if not tag:
    return
  parent, sep, base = tag.rpartition('/')
  default_variant, _, _ = base.partition('(')
  if default_variant != base:
    yield sep.join((parent, default_variant))
  yield from _self_and_parent_tags(parent)


class Registry:
  """Registry of available snippets."""

  def __init__(self):
    """Initializer."""
    # Maps from tag to things at that tag.
    self._plugins = collections.defaultdict(list)
    self._snippets = {}

  def register_plugin(self, tag: str, plugin_: plugin.Plugin) -> None:
    """Registers a plugin.

    Args:
      tag: Tag of the scope of the plugin. E.g., 'foo/bar' applies to the
        snippet 'foo/bar' and all snippets that start with 'foo/bar/'. If this
        is the empty string, the plugin applies to all snippets.
      plugin_: Plugin to register.
    """
    self._plugins[tag].append(plugin_)

  def register_snippet(self, tag: str, snippet_: snippet.Snippet) -> None:
    """Registers a snippet.

    Args:
      tag: Short string to identify the snippet.
      snippet_: Snippet instance.
    """
    self._snippets[tag] = snippet_

  def variants(self, tag: str) -> Generator[str, None, None]:
    """Yields all variants of the given tag.

    Args:
      tag: Tag to get variants of.
    """
    for scope in _self_and_parent_tags(tag):
      for plugin_ in plugin.recurse(self._plugins[scope], plugin.SnippetPlugin):
        yield from plugin_.variants

  def tags(self, context_: context.Context) -> Generator[str, None, None]:
    """Yields all applicable snippet tags, including variants.

    Args:
      context_: Context in which the snippet could be expanded.
    """
    for tag in self._snippets.keys():
      yield tag
      for variant in self.variants(tag):
        yield '{}({})'.format(tag, variant)

  def render(self, tag: str, context_: context.Context) -> str:
    """Returns the expansion of a snippet.

    Args:
      tag: Tag of the snippet to render, including variant information.
      context_: Context to render the template in.

    Raises:
      NotFoundError: The tag was not found.
      snippet.RenderError: Rendering the snippet failed.
    """
    plugins = []
    for scope in _self_and_parent_tags(tag):
      plugins.extend(self._plugins[scope])
    variant = None
    if tag.endswith(')') and '(' in tag:
      tag, _, variant = tag[:-1].rpartition('(')
    try:
      snippet_ = self._snippets[tag]
    except KeyError:
      raise NotFoundError('Unknown snippet {!r}.'.format(tag))
    return snippet_.render(context_, plugins, variant)


def _walk_config_dirs(
    config_dirs: Iterable[str],
    top_level: str,
    extension: str) -> Generator[Tuple[str, str, str, str], None, None]:
  """Yields info about files in the config directories.

  __init__.extension files get the tag of the directory they're in, everything
  else gets the tag of its relative path (minus extension) from its top_level
  directory.

  Directories and files other than __init__ are ignore if they start with '_'.

  Args:
    config_dirs: Configuration directories.
    top_level: Top-level directory in each config dir to walk through.
    extension: File extension to look for.

  Yields:
    Tuples: (path to a top-level directory under config_dirs, relative path to a
    directory within the top-level directory, base filename within the
    directory, tag for the file)
  """
  for config_dir in config_dirs:
    to_walk = os.path.join(config_dir, top_level)
    for dirpath, dirnames, filenames in os.walk(to_walk, followlinks=True):
      dirnames[:] = (x for x in dirnames if not x.startswith('_'))
      dir_relpath = os.path.relpath(dirpath, to_walk)
      dir_tag = dir_relpath.replace(os.path.sep, '/')
      if dir_tag == '.':
        dir_tag = ''
      for filename in filenames:
        if not filename.endswith(extension):
          continue
        file_tag, _, _ = filename.rpartition(extension)
        if file_tag == '__init__':
          tag = dir_tag
        elif file_tag.startswith('_'):
          continue
        else:
          tag = '/'.join(((dir_tag,) if dir_tag else ()) + (file_tag,))
        yield to_walk, dir_relpath, filename, tag


def load_python_plugins(registry: Registry, config_dirs: Iterable[str]) -> None:
  """Loads Python plugins.

  Args:
    registry: Registry to load plugins into.
    config_dirs: Configuration directories.
  """
  for top_level, dir_relpath, filename, tag in _walk_config_dirs(
      config_dirs, 'snippets', '.py'):
    registry.register_plugin(tag, plugin.PythonMetaPlugin(
      os.path.join(top_level, dir_relpath, filename)))


class _Jinja2Undefined(jinja2.Undefined):
  """Undefined variable handler for jinja2 snippets.

  This puts a placeholder in the expansion of the snippet.
  """

  def __str__(self):
    return '@!{}!@'.format(self._undefined_name)


def load_jinja2_snippets(
    registry: Registry, config_dirs: Iterable[str]) -> None:
  """Loads Jinja2 snippets.

  Args:
    registry: Registry to load snippets into.
    config_dirs: Configuration directories.
  """
  environment = jinja2.Environment(
      undefined=_Jinja2Undefined,
      autoescape=False,
      loader=jinja2.FileSystemLoader(
          [os.path.join(path, 'snippets') for path in config_dirs]),
  )
  # TODO: Make comment.block a plugin.
  environment.filters['comment.block'] = comment.block
  for top_level, dir_relpath, filename, tag in _walk_config_dirs(
      config_dirs, 'snippets', '.jinja2'):
    registry.register_snippet(
        tag,
        snippet.Jinja2Snippet(
            environment.get_template(os.path.join(dir_relpath, filename))))


def default_registry(config_dirs: Optional[Iterable[str]] = None) -> Registry:
  """Returns the default snippet registry.

  Args:
    config_dirs: Directories to search for snippets in, or None to use the
      defaults.
  """
  if config_dirs is None:
    config_dirs = [
        os.path.join(os.getenv('HOME'), '.config', 'snipphthalate'),
    ]
  registry = Registry()
  load_python_plugins(registry, config_dirs)
  load_jinja2_snippets(registry, config_dirs)
  return registry
