# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Code for a registry of multiple snippets."""


import importlib
import os
from typing import Generator, Iterable, Optional, Tuple

import jinja2

from snipphthalate import comment
from snipphthalate import context
from snipphthalate import snippet


class NotFoundError(snippet.RenderError):
  """A snippet was not found."""


class Registry:
  """Registry of available snippets."""

  def __init__(self):
    """Initializer."""
    self._snippets = {}  # Map from tag to Snippet instance.

  def register(self, tag: str, snippet_: snippet.Snippet):
    """Registers a snippet.

    Args:
      tag: Short string to identify the snippet.
      snippet_: Snippet instance.
    """
    self._snippets[tag] = snippet_

  def tags(self, context_: context.Context) -> Iterable[str]:
    """Returns an iterable of all applicable snippet tags.

    Args:
      context_: Context in which the snippet could be expanded.
    """
    return self._snippets.keys()

  def render(self, tag: str, context_: context.Context) -> str:
    """Returns the expansion of a snippet.

    Args:
      tag: Tag of the snippet to render.
      context_: Context to render the template in.

    Raises:
      NotFoundError: The tag was not found.
      snippet.RenderError: Rendering the snippet failed.
    """
    try:
      snippet_ = self._snippets[tag]
    except KeyError:
      raise NotFoundError('Unknown snippet {!r}.'.format(tag))
    return snippet_.render(context_)


def _walk_config_dirs(
    config_dirs: Iterable[str],
    top_level: str,
    extension: str) -> Generator[Tuple[str, str, str, str], None, None]:
  """Yields info about files in the config directories.

  __init__.extension files get the tag of the directory they're in, everything
  else gets the tag of its relative path (minus extension) from its top_level
  directory.

  Directories and files other than __init__ are ignore if they start with '_'.

  Args:
    config_dirs: Configuration directories.
    top_level: Top-level directory in each config dir to walk through.
    extension: File extension to look for.

  Yields:
    Tuples: (path to a top-level directory under config_dirs, relative path to a
    directory within the top-level directory, base filename within the
    directory, tag for the file)
  """
  for config_dir in config_dirs:
    to_walk = os.path.join(config_dir, top_level)
    for dirpath, dirnames, filenames in os.walk(to_walk, followlinks=True):
      dirnames[:] = (x for x in dirnames if not x.startswith('_'))
      dir_relpath = os.path.relpath(dirpath, to_walk)
      dir_tag = dir_relpath.replace(os.path.sep, '/')
      if dir_tag == '.':
        dir_tag = ''
      for filename in filenames:
        if not filename.endswith(extension):
          continue
        file_tag, _, _ = filename.rpartition(extension)
        if file_tag == '__init__':
          tag = dir_tag
        elif file_tag.startswith('_'):
          continue
        else:
          tag = '/'.join(((dir_tag,) if dir_tag else ()) + (file_tag,))
        yield to_walk, dir_relpath, filename, tag


class _Jinja2Undefined(jinja2.Undefined):
  """Undefined variable handler for jinja2 snippets.

  This puts a placeholder in the expansion of the snippet.
  """

  def __str__(self):
    return '@!{}!@'.format(self._undefined_name)


def load_jinja2(registry: Registry, config_dirs: Iterable[str]) -> None:
  """Loads Jinja2 snippets.

  Args:
    registry: Registry to load snippets into.
    config_dirs: Directories to search for snippets in.
  """
  environment = jinja2.Environment(
      undefined=_Jinja2Undefined,
      autoescape=False,
      loader=jinja2.FileSystemLoader(
          [os.path.join(path, 'snippets') for path in config_dirs]),
  )
  environment.filters['comment.block'] = comment.block

  # Load snippets with python configuration.
  dirs_with_python = set()
  for top_level, dir_relpath, filename, tag in _walk_config_dirs(
      config_dirs, 'snippets', '.py'):
    dirs_with_python.add(dir_relpath)
    spec = importlib.util.spec_from_file_location(
        '<snipphthalate_snippet>',
        os.path.join(top_level, dir_relpath, filename))
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    if hasattr(module, 'register_jinja2'):
      module.register_jinja2(registry, environment)

  # Load snippets without python configuration.
  for top_level, dir_relpath, filename, tag in _walk_config_dirs(
      config_dirs, 'snippets', '.jinja2'):
    if any((x == os.path.commonpath((x, dir_relpath))
            for x in dirs_with_python)):
      continue
    registry.register(
        tag,
        snippet.Jinja2Snippet(
            environment.get_template(os.path.join(dir_relpath, filename))))


def default_registry(config_dirs: Optional[Iterable[str]] = None) -> Registry:
  """Returns the default snippet registry.

  Args:
    config_dirs: Directories to search for snippets in, or None to use the
      defaults.
  """
  if config_dirs is None:
    config_dirs = [
        os.path.join(os.getenv('HOME'), '.config', 'snipphthalate'),
    ]
  registry = Registry()
  load_jinja2(registry, config_dirs)
  return registry
