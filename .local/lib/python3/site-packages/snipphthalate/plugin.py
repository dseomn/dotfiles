# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Plugin interfaces for snipphthalate."""


import importlib
from typing import Any, Dict, Generator, Iterable, List, Optional, Type, TypeVar

import jsonschema
import yaml

from snipphthalate import context


class Plugin:
  """Base for all plugins."""


PluginType = TypeVar('PluginType', bound=Plugin)


class MetaPlugin(Plugin):
  """Plugin that contains other plugins.

  Attributes:
    children: Child plugins.
  """

  def __init__(self):
    """Initializer."""
    self.children = []  # type: List[Plugin]


def recurse(
    plugins: Iterable[Plugin],
    plugin_type: Type[PluginType] = Plugin,
) -> Generator[PluginType, None, None]:
  """Yields each plugin, recursively.

  Args:
    plugins: Plugins to iterate over.
    plugin_type: Type of plugin to yield.
  """
  for plugin in plugins:
    if isinstance(plugin, MetaPlugin):
      yield from recurse(plugin.children, plugin_type)
    if isinstance(plugin, plugin_type):
      yield plugin


class PythonMetaPlugin(MetaPlugin):
  """Meta-plugin that loads other plugins from a python file.

  All plugins defined in a given python file (except for private ones with names
  that start with '_') are loaded as child plugins.
  """

  def __init__(self, filename):
    """Initializer.

    Args:
      filename: File to load plugins from.
    """
    super().__init__()
    spec = importlib.util.spec_from_file_location(
        '<snipphthalate_plugin>', filename)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    for key, value in vars(module).items():
      if key.startswith('_'):
        continue
      if isinstance(value, type) and issubclass(value, Plugin):
        self.children.append(value())


class SnippetPlugin(Plugin):
  """Plugin that affects individual snippet(s).

  Attributes:
    variants: Names of variations on each snippet this plugin applies to. E.g.,
      this could be ['iso8601', 'rfc5322'] for a 'datetime' snippet. Then the
      snippets available to the user would be 'datetime', 'datetime(iso8601)',
      and 'datetime(rfc5322)'.
  """

  def __init__(self):
    """Initializer."""
    super().__init__()
    self.variants = []  # type: List[str]

  def is_applicable(
      self,
      snipphthalate_context: context.Context,
      tag: str,
      variant: Optional[str]) -> bool:
    """Returns whether the given tag and variant are applicable in the context.

    When there are multiple SnippetPlugins for a snippet, they must all return
    True for the snippet to be considered applicable.

    Args:
      snipphthalate_context: Context of the file to test the snippet's
        applicability in.
      tag: Tag of the snippet, not including variant information.
      variant: Variant of the snippet, or None for the default variant.
    """
    return True


class Jinja2SnippetPlugin(SnippetPlugin):
  """Plugin that affects individual Jinja2 snippet(s)."""

  def update_context(
      self,
      jinja2_context: Dict[str, Any],
      snipphthalate_context: context.Context,
      variant: Optional[str]) -> None:
    """Updates the context for Jinja2 rendering.

    Args:
      jinja2_context: Context to update. After all plugins make their
        modifications, this will be used to render the template.
      snipphthalate_context: Context of the file the snippet will go in.
      variant: Which variant of the snippet to update the context for, or None
        for the default variant.
    """


class YamlPlugin(Jinja2SnippetPlugin):
  """Plugin based on YAML configuration."""

  _SCHEMA = {
      '$schema': 'http://json-schema.org/draft-04/schema#',
      'type': 'object',
      'properties': {
          'env': {
              '$ref': '#/definitions/env',
          },
          'variants': {
              'type': 'object',
              'additionalProperties': {
                  'type': 'object',
                  'properties': {
                      'env': {
                          '$ref': '#/definitions/env',
                      },
                  },
              },
          },
      },
      'definitions': {
          'env': {
              'type': 'object',
          },
      },
  }

  def __init__(self, filename):
    """Initializer.

    Args:
      filename: File to load YAML config from.
    """
    super().__init__()
    with open(filename, 'r') as fh:
      contents = fh.read()
    self._config = yaml.safe_load(contents)
    jsonschema.validate(self._config, self._SCHEMA)
    self.variants.extend(self._config.get('variants', {}).keys())

  def update_context(
      self,
      jinja2_context: Dict[str, Any],
      snipphthalate_context: context.Context,
      variant: Optional[str]) -> None:
    jinja2_context.update(self._config.get('env', {}))
    if variant is not None:
      jinja2_context.update(
          self._config.get('variants', {}).get(variant, {}).get('env', {}))
